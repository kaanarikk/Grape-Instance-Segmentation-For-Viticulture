# -*- coding: utf-8 -*-
"""Grape-Instance-Segmentation-For-Viticulture.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12L8SiuTgO7DsznGo8-7zzrTZmsgp-68G
"""

!nvidia-smi

import os
HOME = os.getcwd()
print(HOME)

# Commented out IPython magic to ensure Python compatibility.
# %pip install "ultralytics<=8.3.50" supervision roboflow
# prevent ultralytics from tracking your activity
!yolo settings sync=False
import ultralytics
ultralytics.checks()

# Commented out IPython magic to ensure Python compatibility.
# %pip install "ultralytics<=8.3.50" supervision roboflow
# prevent ultralytics from tracking your activity
!yolo settings sync=False
import ultralytics
ultralytics.checks()

import torch
import torch.nn as nn
from ultralytics import YOLO
from ultralytics.nn.modules.block import C2f

# ===== ASPP Module =====
class ASPP(nn.Module):
    def __init__(self, in_channels, out_channels=256, atrous_rates=[6, 12, 18]):
        super().__init__()
        self.conv1 = nn.Sequential(
            nn.Conv2d(in_channels, out_channels, 1, bias=False),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True)
        )
        self.conv2 = nn.Sequential(
            nn.Conv2d(in_channels, out_channels, 3, padding=atrous_rates[0], dilation=atrous_rates[0], bias=False),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True)
        )
        self.conv3 = nn.Sequential(
            nn.Conv2d(in_channels, out_channels, 3, padding=atrous_rates[1], dilation=atrous_rates[1], bias=False),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True)
        )
        self.conv4 = nn.Sequential(
            nn.Conv2d(in_channels, out_channels, 3, padding=atrous_rates[2], dilation=atrous_rates[2], bias=False),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True)
        )
        self.global_pool = nn.Sequential(
            nn.AdaptiveAvgPool2d(1),
            nn.Conv2d(in_channels, out_channels, 1, bias=False),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True)
        )
        self.project = nn.Sequential(
            nn.Conv2d(out_channels * 5, out_channels, 1, bias=False),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True)
        )

    def forward(self, x):
        size = x.shape[2:]
        feat1 = self.conv1(x)
        feat2 = self.conv2(x)
        feat3 = self.conv3(x)
        feat4 = self.conv4(x)
        pool = self.global_pool(x)
        pool = nn.functional.interpolate(pool, size=size, mode='bilinear', align_corners=False)
        out = torch.cat([feat1, feat2, feat3, feat4, pool], dim=1)
        out = self.project(out)
        return out

# ===== ASPP Entegrasyonu =====
def integrate_aspp_to_yolo(yolo_model, aspp_channels=256):
    layers = yolo_model.model.model
    c2f_indices = [i for i, l in enumerate(layers) if isinstance(l, C2f)]
    last_c2f_idx = c2f_indices[-1]
    last_c2f = layers[last_c2f_idx]
    out_channels = last_c2f.cv2.conv.out_channels
    layers.insert(last_c2f_idx + 1, ASPP(out_channels, aspp_channels))
    print(f"ASPP added: {last_c2f_idx+1} index, in_channels={out_channels}, out_channels={aspp_channels}")
    return yolo_model

# ===== Main =====
def main():
    device = 'cuda' if torch.cuda.is_available() else 'cpu'

    yolo = YOLO('yolo11s-seg.pt')
    yolo.model.to(device)

    yolo = integrate_aspp_to_yolo(yolo, aspp_channels=256)

    yolo.train(
        data='/teamspace/studios/this_studio/Grape-Segmentation---yedek---kendi-verim-26/data.yaml',
        epochs=25,
        imgsz=640,
        batch=16,
        project='YOLOv11s_ASPP_InstSeg',
        name='exp1',
        device=device,
        exist_ok=True,
        optimizer='AdamW',
        lr0=0.01
    )

if __name__ == '__main__':
    main()
